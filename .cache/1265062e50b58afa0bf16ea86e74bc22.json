{"dependencies":[{"name":"./health.js","loc":{"line":1,"column":23}},{"name":"./collisions","loc":{"line":2,"column":55}},{"name":"./movable","loc":{"line":12,"column":7}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Enemy = undefined;\n\nvar _health = require(\"./health.js\");\n\nvar _collisions = require(\"./collisions\");\n\nvar _movable = require(\"./movable\");\n\nconst Enemy = (constraints, { damagePower, dimensions, imageStates }) => {\n  let health = (0, _health.Health)();\n\n  let pos = {\n    x: constraints[0] / 4,\n    y: constraints[1] / 4\n  };\n  let acceleration = {\n    x: 0,\n    y: 0\n  };\n  const velocityMap = {\n    default: 5,\n    running: 7\n  };\n  const accelStep = .025;\n  const decelStep = .01;\n\n  let isRepelling = false;\n\n  const walkingMap = [{\n    duration: 2000,\n    direction: 'right'\n  }, {\n    duration: 2000,\n    direction: 'left'\n  }];\n  let attackThreshold = 500;\n\n  const getInput = (0, _movable.getWalkCycle)(walkingMap);\n  const velocity = velocityMap['default'];\n  let currentImageState = 'default';\n\n  const updatePosition = (target, nearestItem) => {\n    const input = getInput();\n    const isAlive = health.getHealth() > 0;\n    const isDying = isAlive && health.getHealth() < 50;\n    let newAcceleration = acceleration;\n    let newPos;\n\n    // attraction\n    let [dx, dy, distance] = (0, _movable.calculateDistance)(pos, isDying && nearestItem ? nearestItem : target);\n    let isAttacking = isAlive && distance !== false && Math.abs(distance) < attackThreshold;\n    if (isAttacking || isDying && nearestItem) {\n      newAcceleration = (0, _movable.attractCalc)(newAcceleration, isAlive ? accelStep : 0, dx, dy);\n    } else {\n      newAcceleration = (0, _movable.calculateInputDeceleration)(acceleration, decelStep);\n    }\n\n    newAcceleration = (0, _movable.calculateCollisionAcceleration)(newAcceleration, getPos(), constraints, isRepelling);\n    newPos = (0, _movable.calculatePos)(pos, newAcceleration, velocity);\n\n    // MUTATIONS\n    pos = newPos;\n    acceleration = newAcceleration;\n    isRepelling = false;\n  };\n\n  const attract = () => {\n    let [x, y] = (0, _movable.attractCalc)(pos.x, pos.y, targetX, targetY);\n\n    pos = { x, y };\n  };\n\n  const repel = data => {\n    isRepelling = data;\n  };\n\n  const getDamagePower = () => damagePower;\n\n  const detectCollision = item => (0, _collisions.detectCollision)(getBoundingBox())(item);\n\n  const getBoundingBox = () => [pos.x, pos.x + dimensions.width, pos.y, pos.y + dimensions.height];\n\n  const getPos = () => Object.assign({}, pos, dimensions);\n\n  const heal = amount => {\n    if (currentImageState === 'dead') return;\n    health.heal(amount);\n  };\n\n  let hurtStateTimeout;\n  const hurt = amount => {\n    health.hurt(amount);\n    console.log('amount', amount);\n\n    currentImageState = 'hurt';\n\n    if (hurtStateTimeout) clearTimeout(hurtStateTimeout);\n    if (health.getHealth() === 0) {\n      currentImageState = 'dead';\n      return;\n    }\n    hurtStateTimeout = setTimeout(() => {\n      currentImageState = 'default';\n    }, 750);\n  };\n\n  const render = ctx => {\n    renderSelf(ctx);\n    health.renderHealthBar(ctx, getPos());\n  };\n\n  const renderSelf = ctx => {\n    imageStates[currentImageState].render(ctx, pos.x, pos.y, acceleration.x < 0);\n  };\n\n  const output = {\n    attract,\n    updatePosition,\n    getBoundingBox,\n    getDamagePower,\n    detectCollision,\n    heal,\n    hurt,\n    getPos,\n    repel,\n    render\n  };\n\n  return Object.assign({}, health, output);\n};\n\nexports.Enemy = Enemy;"},"hash":"9e619c717003c7e40bf6b6b914c0549d"}
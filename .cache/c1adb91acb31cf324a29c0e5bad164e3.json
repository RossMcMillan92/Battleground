{"dependencies":[],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst attractCalc = (curAccerl, accelStep, dx, dy) => {\n  let [ax, ay] = [curAccerl.x, curAccerl.y];\n\n  ax = calculateAcceleration(ax, accelStep, dx < 0 ? -1 : 1);\n  ay = calculateAcceleration(ay, accelStep, dy < 0 ? -1 : 1);\n\n  return {\n    x: ax,\n    y: ay\n  };\n};\n\nconst calculateDistance = (pos, target) => {\n  const dx = target.x - pos.x;\n  const dy = target.y - pos.y;\n  return [dx, dy, Math.sqrt(dx * dx + dy * dy)];\n};\n\nconst calculateVelocity = (velocityMap, input) => {\n  let velocityType = 'default';\n  if (input.shift) velocityType = 'running';\n\n  return velocityMap[velocityType];\n};\n\nconst calculateInputAcceleration = (curAccel, accelStep, decelStep, input) => {\n  let [ax, ay] = [curAccel.x, curAccel.y];\n\n  // Controls\n  if (input.right) ax = calculateAcceleration(ax, ax > 0 ? accelStep : decelStep);\n  if (input.left) ax = calculateAcceleration(ax, ax > 0 ? decelStep : accelStep, -1);\n  if (input.down) ay = calculateAcceleration(ay, ay > 0 ? accelStep : decelStep);\n  if (input.up) ay = calculateAcceleration(ay, ay > 0 ? decelStep : accelStep, -1);\n\n  return {\n    x: ax,\n    y: ay\n  };\n};\n\nconst calculateInputDeceleration = (curAccel, decelStep, input = {}) => {\n  let [ax, ay] = [curAccel.x, curAccel.y];\n\n  // Deceleration\n  if (ax !== 0 && !input.left && !input.right) ax = calculateDeceleration(ax, decelStep);\n  if (ay !== 0 && !input.up && !input.down) ay = calculateDeceleration(ay, decelStep);\n\n  return {\n    x: ax,\n    y: ay\n  };\n};\n\nconst calculateCollisionAcceleration = (curAccel, pos, constraints, isHurt) => {\n  let [x, y] = [pos.x, pos.y];\n  let [ax, ay] = [curAccel.x, curAccel.y];\n\n  if (isHurt.axis === 'x') ax = isHurt.direction;\n  if (isHurt.axis === 'y') ay = isHurt.direction;\n\n  // Constraints\n  if (x + pos.width > constraints[0] && ax > 0 || x < 0 && ax < 0) ax = ax * -.5;\n  if (y + pos.height > constraints[1] && ay > 0 || y < 0 && ay < 0) ay = ay * -.5;\n\n  return {\n    x: ax,\n    y: ay\n  };\n};\n\nconst calculateAcceleration = (curAccel, accelStep, dir = 1) => {\n  const result = curAccel + accelStep * dir;\n  return dir === 1 ? Math.min(1, result) : Math.max(-1, result);\n};\n\nconst calculateDeceleration = (curAccel, decelStep) => {\n  return curAccel < decelStep && curAccel > -decelStep ? 0 : calculateAcceleration(curAccel, decelStep, curAccel > 0 ? -1 : 1);\n};\n\nconst calculatePos = (pos, acceleration, velocity) => {\n  return {\n    x: Math.round(pos.x + velocity * acceleration.x),\n    y: Math.round(pos.y + velocity * acceleration.y)\n  };\n};\n\nconst getWalkCycle = walkCycle => {\n  let lastUpdateTime = performance.now();\n  let index = 0;\n\n  return () => {\n    let data = {};\n    let currentSection = walkCycle[index];\n    let currentDirection = currentSection.direction;\n    let currentDuration = currentSection.duration;\n    const currentTime = performance.now();\n\n    if (currentTime > lastUpdateTime + currentDuration) {\n      index = index < walkCycle.length - 1 ? index + 1 : 0;\n      lastUpdateTime = currentTime;\n    }\n\n    data[currentDirection] = true;\n    return data;\n  };\n};\n\nexports.attractCalc = attractCalc;\nexports.calculateDistance = calculateDistance;\nexports.calculateVelocity = calculateVelocity;\nexports.calculateInputAcceleration = calculateInputAcceleration;\nexports.calculateInputDeceleration = calculateInputDeceleration;\nexports.calculateCollisionAcceleration = calculateCollisionAcceleration;\nexports.calculateAcceleration = calculateAcceleration;\nexports.calculateDeceleration = calculateDeceleration;\nexports.calculatePos = calculatePos;\nexports.getWalkCycle = getWalkCycle;"},"hash":"c16d8f10d6aa5e05c62bcce3ee4315c7"}